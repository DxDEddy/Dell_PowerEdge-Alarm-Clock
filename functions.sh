function apply_Dell_default_fan_control_profile() {
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0x30 0x01 0x01 > /dev/null
  CURRENT_FAN_CONTROL_PROFILE="Dell default dynamic fan control profile"
}

function apply_user_fan_control_profile() {
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0x30 0x01 0x00 > /dev/null
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0x30 0x02 0xff $HEXADECIMAL_FAN_SPEED > /dev/null
  CURRENT_FAN_CONTROL_PROFILE="User static fan control profile ($DECIMAL_FAN_SPEED%)"
}

# Convert first parameter given ($DECIMAL_NUMBER) to hexadecimal
# Usage : convert_decimal_value_to_hexadecimal $DECIMAL_NUMBER
# Returns : hexadecimal value of DECIMAL_NUMBER
function convert_decimal_value_to_hexadecimal() {
  local -r DECIMAL_NUMBER=$1
  local -r HEXADECIMAL_NUMBER=$(printf '0x%02x' $DECIMAL_NUMBER)
  echo $HEXADECIMAL_NUMBER
}

# Convert first parameter given ($HEXADECIMAL_NUMBER) to decimal
# Usage : convert_hexadecimal_value_to_decimal "$HEXADECIMAL_NUMBER"
# Returns : decimal value of HEXADECIMAL_NUMBER
function convert_hexadecimal_value_to_decimal() {
  local -r HEXADECIMAL_NUMBER=$1
  local -r DECIMAL_NUMBER=$(printf '%d' $HEXADECIMAL_NUMBER)
  echo $DECIMAL_NUMBER
}

# Set the IDRAC_LOGIN_STRING variable based on connection type
# Usage : set_iDRAC_login_string $IDRAC_HOST $IDRAC_USERNAME $IDRAC_PASSWORD
# Returns : IDRAC_LOGIN_STRING
function set_iDRAC_login_string() {
  local IDRAC_HOST="$1"
  local IDRAC_USERNAME="$2"
  local IDRAC_PASSWORD="$3"

  IDRAC_LOGIN_STRING=""

  # Check if the iDRAC host is set to 'local' or not then set the IDRAC_LOGIN_STRING accordingly
  if [[ "$IDRAC_HOST" == "local" ]]; then
    # Check that the Docker host IPMI device (the iDRAC) has been exposed to the Docker container
    if [ ! -e "/dev/ipmi0" ] && [ ! -e "/dev/ipmi/0" ] && [ ! -e "/dev/ipmidev/0" ]; then
      print_error_and_exit "Could not open device at /dev/ipmi0 or /dev/ipmi/0 or /dev/ipmidev/0, check that you added the device to your Docker container or stop using local mode"
    fi
    IDRAC_LOGIN_STRING='open'
  else
    echo "iDRAC/IPMI username: $IDRAC_USERNAME"
    #echo "iDRAC/IPMI password: $IDRAC_PASSWORD"
    IDRAC_LOGIN_STRING="lanplus -H $IDRAC_HOST -U $IDRAC_USERNAME -P $IDRAC_PASSWORD"
  fi
}

# Retrieve temperature sensors data using ipmitool
# Usage : retrieve_temperatures $IS_EXHAUST_TEMPERATURE_SENSOR_PRESENT $IS_CPU2_TEMPERATURE_SENSOR_PRESENT
function retrieve_temperatures() {
  if (( $# != 2 )); then
    print_error "Illegal number of parameters.\nUsage: retrieve_temperatures \$IS_EXHAUST_TEMPERATURE_SENSOR_PRESENT \$IS_CPU2_TEMPERATURE_SENSOR_PRESENT"
    return 1
  fi
  local -r IS_EXHAUST_TEMPERATURE_SENSOR_PRESENT=$1
  local -r IS_CPU2_TEMPERATURE_SENSOR_PRESENT=$2

  local -r DATA=$(ipmitool -I $IDRAC_LOGIN_STRING sdr type temperature | grep degrees)

  # Parse CPU data
  local -r CPU_DATA=$(echo "$DATA" | grep "3\." | grep -Po '\d{2}')
  CPU1_TEMPERATURE=$(echo $CPU_DATA | awk "{print \$$CPU1_TEMPERATURE_INDEX;}")
  if $IS_CPU2_TEMPERATURE_SENSOR_PRESENT; then
    CPU2_TEMPERATURE=$(echo $CPU_DATA | awk "{print \$$CPU2_TEMPERATURE_INDEX;}")
  else
    CPU2_TEMPERATURE="-"
  fi

  # Initialize CPUS_TEMPERATURES
  CPUS_TEMPERATURES="$CPU1_TEMPERATURE"
  NUMBER_OF_DETECTED_CPUS=1

  # If CPU2 is present, parse its temperature data and add it to CPUS_TEMPERATURES
  if [ -n "$CPU2_TEMPERATURE" ]; then
    CPUS_TEMPERATURES+=";$CPU2_TEMPERATURE"
    ((NUMBER_OF_DETECTED_CPUS++))
  fi

  # Parse inlet temperature data
  INLET_TEMPERATURE=$(echo "$DATA" | grep Inlet | grep -Po '\d{2}' | tail -1)

  # If exhaust temperature sensor is present, parse its temperature data
  if $IS_EXHAUST_TEMPERATURE_SENSOR_PRESENT; then
    EXHAUST_TEMPERATURE=$(echo "$DATA" | grep Exhaust | grep -Po '\d{2}' | tail -1)
  else
    EXHAUST_TEMPERATURE="-"
  fi
}

# Gen 13 and older only
function enable_third_party_PCIe_card_Dell_default_cooling_response() {
  # We could check the current cooling response before applying but it's not very useful so let's skip the test and apply directly
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0xce 0x00 0x16 0x05 0x00 0x00 0x00 0x05 0x00 0x00 0x00 0x00 > /dev/null
}

# Gen 13 and older only
function disable_third_party_PCIe_card_Dell_default_cooling_response() {
  # We could check the current cooling response before applying but it's not very useful so let's skip the test and apply directly
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0xce 0x00 0x16 0x05 0x00 0x00 0x00 0x05 0x00 0x01 0x00 0x00 > /dev/null
}

# Returns :
# - 0 if third-party PCIe card Dell default cooling response is currently DISABLED
# - 1 if third-party PCIe card Dell default cooling response is currently ENABLED
# - 2 if the current status returned by ipmitool command output is unexpected
# function is_third_party_PCIe_card_Dell_default_cooling_response_disabled() {
#   THIRD_PARTY_PCIE_CARD_COOLING_RESPONSE=$(ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0xce 0x01 0x16 0x05 0x00 0x00 0x00)

#   if [ "$THIRD_PARTY_PCIE_CARD_COOLING_RESPONSE" == "16 05 00 00 00 05 00 01 00 00" ]; then
#     return 0
#   elif [ "$THIRD_PARTY_PCIE_CARD_COOLING_RESPONSE" == "16 05 00 00 00 05 00 00 00 00" ]; then
#     return 1
#   else
#     print_error "Unexpected output: $THIRD_PARTY_PCIE_CARD_COOLING_RESPONSE"
#     return 2
#   fi
# }

# Trap handler for container shutdown
function graceful_exit() {
  apply_Dell_default_fan_control_profile

  # Reset third-party PCIe card cooling response to Dell default depending on the user's choice at startup
  if ! "$KEEP_THIRD_PARTY_PCIE_CARD_COOLING_RESPONSE_STATE_ON_EXIT"; then
    enable_third_party_PCIe_card_Dell_default_cooling_response
  fi

  print_warning_and_exit "Container stopped, Dell default dynamic fan control profile applied for safety"
}

# Helps debugging when people are posting their output
function get_Dell_server_model() {
  local -r IPMI_FRU_content=$(ipmitool -I $IDRAC_LOGIN_STRING fru 2>/dev/null) # FRU stands for "Field Replaceable Unit"

  SERVER_MANUFACTURER=$(echo "$IPMI_FRU_content" | grep "Product Manufacturer" | awk -F ': ' '{print $2}')
  SERVER_MODEL=$(echo "$IPMI_FRU_content" | grep "Product Name" | awk -F ': ' '{print $2}')

  # Check if SERVER_MANUFACTURER is empty, if yes, assign value based on "Board Mfg"
  if [ -z "$SERVER_MANUFACTURER" ]; then
    SERVER_MANUFACTURER=$(echo "$IPMI_FRU_content" | tr -s ' ' | grep "Board Mfg :" | awk -F ': ' '{print $2}')
  fi

  # Check if SERVER_MODEL is empty, if yes, assign value based on "Board Product"
  if [ -z "$SERVER_MODEL" ]; then
    SERVER_MODEL=$(echo "$IPMI_FRU_content" | tr -s ' ' | grep "Board Product :" | awk -F ': ' '{print $2}')
  fi
}

function build_header() {
  # Check number of arguments
  if [ "$#" -ne 1 ]; then
    print_error "build_header() requires an argument (number_of_CPUs)"
    return 1
  fi

  local -r number_of_CPUs="$1"
  local -r CPU_column_width=7
  local -r Exhaust_column_width=9

  local header="                     ----" # Width ready for 1 CPU

  # Calculate the number of dashes to add on each side of the title
  number_of_dashes=$(((number_of_CPUs-1)*CPU_column_width/2))

  # Loop to add dashes
  for ((i=1; i<=number_of_dashes; i++)); do
    header+="-"
  done

  header+=" Temperatures ---"

  # Check parity and add an extra dash on the right if odd
  if (( (number_of_CPUs - 1) * CPU_column_width % 2 != 0 )); then
    header+="-"
  fi

  # Loop to add dashes
  for ((i=1; i<=number_of_dashes; i++)); do
    header+="-"
  done
  header+=$'\n    Date & time      Inlet  CPU 1 '

  # Loop to add CPU columns
  for ((i=2; i<=number_of_CPUs; i++)); do
    header+=" CPU $i "
  done

  header+=$' Exhaust          Active fan speed profile          Third-party PCIe card Dell default cooling response  Comment'
  printf "%s" "$header"
}

function print_temperature_array_line() {
  local -r LOCAL_INLET_TEMPERATURE="$1"
  local -r LOCAL_CPUS_TEMPERATURES="$2"
  local -r LOCAL_EXHAUST_TEMPERATURE="$3"
  local -r LOCAL_CURRENT_FAN_CONTROL_PROFILE="$4"
  local -r LOCAL_THIRD_PARTY_PCIE_CARD_DELL_DEFAULT_COOLING_RESPONSE_STATUS="$5"
  local -r LOCAL_COMMENT="$6"

  # Creating an array from the string
  local -r CPUs_temperatures_array=(${LOCAL_CPUS_TEMPERATURES//;/ })

  printf "%19s  %3d°C " "$(date +"%d-%m-%Y %T")" $LOCAL_INLET_TEMPERATURE
  # Loop through CPU temperatures
  for temperature in "${CPUs_temperatures_array[@]}"; do
    printf " %3d°C " $temperature
  done

  printf " %5s°C  %40s  %51s  %s\n" "$LOCAL_EXHAUST_TEMPERATURE" "$LOCAL_CURRENT_FAN_CONTROL_PROFILE" "$LOCAL_THIRD_PARTY_PCIE_CARD_DELL_DEFAULT_COOLING_RESPONSE_STATUS" "$LOCAL_COMMENT"
}

function CPU1_OVERHEATING() { [ $CPU1_TEMPERATURE -gt "$CPU_TEMPERATURE_THRESHOLD" ]; }
function CPU2_OVERHEATING() { [ $CPU2_TEMPERATURE -gt "$CPU_TEMPERATURE_THRESHOLD" ]; }

# Check if the current day matches a days string
# Usage: is_alarm_day "$days_string"
# $days_string is a comma-separated list like "Mon,Tue,Wed" or "*" for every day
function is_alarm_day() {
  local DAYS_STRING="$1"

  if [[ "$DAYS_STRING" == "*" ]]; then
    return 0
  fi

  local CURRENT_DAY
  CURRENT_DAY=$(LC_TIME=C date +%a)

  local DAY_ARRAY
  IFS=',' read -ra DAY_ARRAY <<< "$DAYS_STRING"
  for DAY in "${DAY_ARRAY[@]}"; do
    DAY=$(echo "$DAY" | tr -d ' ')
    if [[ "${DAY,,}" == "${CURRENT_DAY,,}" ]]; then
      return 0
    fi
  done

  return 1
}

# Check if the current time is within the alarm window
# Usage: is_in_alarm_window "$start_time" "$end_time"
# Handles overnight windows (e.g., 23:00-01:00) where start > end
function is_in_alarm_window() {
  local ALARM_START="$1"
  local ALARM_END="$2"

  local CURRENT_TIME CURRENT_HOUR CURRENT_MIN START_HOUR START_MIN END_HOUR END_MIN
  CURRENT_TIME=$(date +%H:%M)
  CURRENT_HOUR="${CURRENT_TIME%%:*}"
  CURRENT_MIN="${CURRENT_TIME##*:}"

  START_HOUR="${ALARM_START%%:*}"
  START_MIN="${ALARM_START##*:}"
  END_HOUR="${ALARM_END%%:*}"
  END_MIN="${ALARM_END##*:}"

  local CURRENT_MINUTES=$(( 10#$CURRENT_HOUR * 60 + 10#$CURRENT_MIN ))
  local START_MINUTES=$(( 10#$START_HOUR * 60 + 10#$START_MIN ))
  local END_MINUTES=$(( 10#$END_HOUR * 60 + 10#$END_MIN ))

  if (( START_MINUTES <= END_MINUTES )); then
    (( CURRENT_MINUTES >= START_MINUTES && CURRENT_MINUTES < END_MINUTES ))
  else
    (( CURRENT_MINUTES >= START_MINUTES || CURRENT_MINUTES < END_MINUTES ))
  fi
}

# Ping each host and return 0 (online) or 1 (offline) via exit code
# Usage: check_alarm_hosts "$hosts_csv" "$logic"
# $logic: "any" = one host up is enough, "all" = every host must be up
function check_alarm_hosts() {
  local HOSTS_CSV="$1"
  local LOGIC="${2:-any}"
  local HOST_UP_COUNT=0
  local HOST_TOTAL=0
  local HOST_ARRAY

  IFS=',' read -ra HOST_ARRAY <<< "$HOSTS_CSV"
  for HOST in "${HOST_ARRAY[@]}"; do
    HOST=$(echo "$HOST" | tr -d ' ')
    [[ -z "$HOST" ]] && continue
    ((HOST_TOTAL++))
    if ping -c 1 -W 2 "$HOST" > /dev/null 2>&1; then
      ((HOST_UP_COUNT++))
    fi
  done

  if [[ "$LOGIC" == "all" ]]; then
    (( HOST_UP_COUNT == HOST_TOTAL && HOST_TOTAL > 0 ))
  else
    (( HOST_UP_COUNT > 0 ))
  fi
}

# Apply the alarm fan control profile (high speed to wake the user up)
# Usage: apply_alarm_fan_control_profile "$hex_speed" "$dec_speed"
function apply_alarm_fan_control_profile() {
  local HEX_SPEED="$1"
  local DEC_SPEED="$2"
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0x30 0x01 0x00 > /dev/null
  ipmitool -I $IDRAC_LOGIN_STRING raw 0x30 0x30 0x02 0xff $HEX_SPEED > /dev/null
  CURRENT_FAN_CONTROL_PROFILE="ALARM fan control profile ($DEC_SPEED%)"
}

# Discover alarm schedules from environment variables
# Scans for ALARM_N_START_TIME patterns. Falls back to legacy single-alarm (index 0)
# if no numbered alarms found but ALARM_START_TIME is set. Populates ALARM_IDS array.
function discover_alarms() {
  ALARM_IDS=()
  for N in $(env | grep -oP '^ALARM_\K[0-9]+(?=_START_TIME=)' | sort -n | uniq); do
    ALARM_IDS+=("$N")
  done
}

# Read alarm config field, with fallback to base ALARM_* variable
# Usage: get_alarm_config "$alarm_id" "$field"
# For alarm 0 (legacy), reads ALARM_FIELD directly.
# For numbered alarms, reads ALARM_N_FIELD, falls back to ALARM_FIELD.
function get_alarm_config() {
  local ALARM_ID="$1" FIELD="$2"
  local VAR_NAME="ALARM_${ALARM_ID}_${FIELD}"
  local VALUE="${!VAR_NAME:-}"
  if [[ -z "$VALUE" ]]; then
    local FALLBACK_VAR="ALARM_${FIELD}"
    VALUE="${!FALLBACK_VAR:-}"
  fi
  echo "$VALUE"
}

function print_error() {
  local -r ERROR_MESSAGE="$1"
  printf "/!\ Error /!\ %s." "$ERROR_MESSAGE" >&2
}

function print_error_and_exit() {
  local -r ERROR_MESSAGE="$1"
  print_error "$ERROR_MESSAGE"
  printf " Exiting.\n" >&2
  exit 1
}

function print_warning() {
  local -r WARNING_MESSAGE="$1"
  printf "/!\ Warning /!\ %s." "$WARNING_MESSAGE"
}

function print_warning_and_exit() {
  local -r WARNING_MESSAGE="$1"
  print_warning "$WARNING_MESSAGE"
  printf " Exiting.\n"
  exit 0
}
